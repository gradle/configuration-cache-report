/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import data.Trie
import elmish.elementById
import elmish.mountComponentAt
import elmish.tree.Tree
import elmish.tree.TreeView
import kotlin.js.JSON.stringify


fun main() {
    mountComponentAt(
        elementById("report"),
        ConfigurationCacheReportPage,
        reportPageModelFromJsModel(configurationCacheProblems())
    )
}


/**
 * External model defined in `configuration-cache-report-data.js`, a file generated by `ConfigurationCacheReport`.
 */
private
external val configurationCacheProblems: () -> JsModel


private
external interface JsModel {
    val cacheAction: String
    val requestedTasks: String
    val documentationLink: String
    val totalProblemCount: Int
    val diagnostics: Array<JsDiagnostic>
}


/** A diagnostic is either an [input] or a [problem] description (not both). */
private
external interface JsDiagnostic {
    val input: Array<JsMessageFragment>?
    val problem: Array<JsMessageFragment>?
    val trace: Array<JsTrace>
    val documentationLink: String?
    val error: String?
}


private
external interface JsTrace {
    val kind: String
}


private
external interface JsTraceProject : JsTrace {
    val path: String
}


private
external interface JsTraceTask : JsTrace {
    val path: String
    val type: String
}


private
external interface JsTraceBean : JsTrace {
    val type: String
}


private
external interface JsTraceField : JsTrace {
    val name: String
    val declaringType: String
}


private
external interface JsTraceProperty : JsTrace {
    val name: String
    val task: String
}


private
external interface JsTracePropertyUsage : JsTrace {
    val name: String
    val from: String
}


private
external interface JsTraceSystemProperty : JsTrace {
    val name: String
}


private
external interface JSBuildLogic : JsTrace {
    val location: String
}


private
external interface JSBuildLogicClass : JsTrace {
    val type: String
}


private
external interface JsMessageFragment {
    val text: String?
    val name: String?
}


private
data class ImportedProblem(
    val problem: JsDiagnostic,
    val message: PrettyText,
    val trace: List<ProblemNode>
)


private
fun reportPageModelFromJsModel(jsModel: JsModel): ConfigurationCacheReportPage.Model {
    val diagnostics = importDiagnostics(jsModel.diagnostics)
    return ConfigurationCacheReportPage.Model(
        cacheAction = jsModel.cacheAction,
        requestedTasks = jsModel.requestedTasks,
        documentationLink = jsModel.documentationLink,
        totalProblems = jsModel.totalProblemCount,
        reportedProblems = diagnostics.problems.size,
        messageTree = treeModelFor(
            ProblemNode.Label("Problems grouped by message"),
            problemNodesByMessage(diagnostics.problems)
        ),
        locationTree = treeModelFor(
            ProblemNode.Label("Problems grouped by location"),
            problemNodesByLocation(diagnostics.problems)
        ),
        reportedInputs = diagnostics.inputs.size,
        inputTree = treeModelFor(
            ProblemNode.Label("Inputs"),
            inputNodes(diagnostics.inputs)
        )
    )
}


private
class ImportedDiagnostics(
    val problems: List<ImportedProblem>,
    val inputs: List<ImportedProblem>
)


private
fun importDiagnostics(jsDiagnostics: Array<JsDiagnostic>): ImportedDiagnostics {
    val importedProblems = mutableListOf<ImportedProblem>()
    val importedInputs = mutableListOf<ImportedProblem>()
    for (diagnostic in jsDiagnostics) {
        diagnostic.input?.let {
            importedInputs.add(toImportedProblem(it, diagnostic))
        } ?: diagnostic.problem!!.let {
            importedProblems.add(toImportedProblem(it, diagnostic))
        }
    }
    return ImportedDiagnostics(importedProblems, importedInputs)
}


private
fun toImportedProblem(label: Array<JsMessageFragment>, jsProblem: JsDiagnostic) = ImportedProblem(
    jsProblem,
    label.let(::toPrettyText),
    jsProblem.trace.map(::toProblemNode)
)


private
fun inputNodes(inputs: List<ImportedProblem>): Sequence<List<ProblemNode>> =
    inputs.asSequence().map { input ->
        buildList {
            val message = input.message
            val inputType = message.fragments.first().unsafeCast<PrettyText.Fragment.Text>().text.trim()
            val inputDescription = message.copy(fragments = message.fragments.drop(1))
            add(
                ProblemNode.Info(
                    ProblemNode.Label(inputType),
                    docLinkFor(input.problem)
                )
            )
            add(ProblemNode.Message(inputDescription))
            addAll(input.trace)
        }
    }


private
fun problemNodesByMessage(problems: List<ImportedProblem>): Sequence<List<ProblemNode>> =
    problems.asSequence().map { problem ->
        buildList {
            add(problemNodeFor(problem))
            addAll(problem.trace)
            addExceptionNode(problem)
        }
    }


private
fun problemNodesByLocation(problems: List<ImportedProblem>): Sequence<List<ProblemNode>> =
    problems.asSequence().map { problem ->
        buildList {
            addAll(problem.trace.asReversed())
            add(problemNodeFor(problem))
            addExceptionNode(problem)
        }
    }


private
fun MutableList<ProblemNode>.addExceptionNode(problem: ImportedProblem) {
    exceptionNodeFor(problem.problem)?.let {
        add(it)
    }
}


private
fun problemNodeFor(problem: ImportedProblem) = errorOrWarningNodeFor(
    problem.problem,
    messageNodeFor(problem),
    docLinkFor(problem.problem)
)


private
fun toPrettyText(message: Array<JsMessageFragment>) = PrettyText(
    message.map {
        it.text?.let(PrettyText.Fragment::Text)
            ?: it.name?.let(PrettyText.Fragment::Reference)
            ?: PrettyText.Fragment.Text("Unrecognised message fragment: ${stringify(it)}")
    }
)


private
fun toProblemNode(trace: JsTrace): ProblemNode = when (trace.kind) {
    "Project" -> trace.unsafeCast<JsTraceProject>().run {
        ProblemNode.Project(path)
    }

    "Task" -> trace.unsafeCast<JsTraceTask>().run {
        ProblemNode.Task(path, type)
    }

    "Bean" -> trace.unsafeCast<JsTraceBean>().run {
        ProblemNode.Bean(type)
    }

    "Field" -> trace.unsafeCast<JsTraceField>().run {
        ProblemNode.Property("field", name, declaringType)
    }

    "InputProperty" -> trace.unsafeCast<JsTraceProperty>().run {
        ProblemNode.Property("input property", name, task)
    }

    "OutputProperty" -> trace.unsafeCast<JsTraceProperty>().run {
        ProblemNode.Property("output property", name, task)
    }

    "SystemProperty" -> trace.unsafeCast<JsTraceSystemProperty>().run {
        ProblemNode.SystemProperty(name)
    }

    "PropertyUsage" -> trace.unsafeCast<JsTracePropertyUsage>().run {
        ProblemNode.Property("property", name, from)
    }

    "BuildLogic" -> trace.unsafeCast<JSBuildLogic>().run {
        ProblemNode.BuildLogic(location)
    }

    "BuildLogicClass" -> trace.unsafeCast<JSBuildLogicClass>().run {
        ProblemNode.BuildLogicClass(type)
    }

    else -> ProblemNode.Label("Gradle runtime")
}


private
fun errorOrWarningNodeFor(problem: JsDiagnostic, label: ProblemNode, docLink: ProblemNode?): ProblemNode =
    problem.error?.let {
        ProblemNode.Error(label, docLink)
    } ?: ProblemNode.Warning(label, docLink)


private
fun messageNodeFor(importedProblem: ImportedProblem) =
    ProblemNode.Message(importedProblem.message)


private
fun exceptionNodeFor(it: JsDiagnostic): ProblemNode? {
    val rawText = it.error ?: return null
    val errLines = rawText.lines()

    return ProblemNode.ExceptionModel(
        rawText,
        message = errLines.first(),
        stackTraceParts = stackTraceParts(errLines.drop(1))
    )
}

fun isGenericCategory(s: String) =
    s.startsWith("at java.base/") ||
            s.startsWith("at jdk.internal") ||
            s.startsWith("at com.sun.proxy") ||
            s.startsWith("at groovy.lang") ||
            s.startsWith("at org.codehaus.groovy")

fun isBuildOperationCategory(s: String) =
    s.startsWith("at org.gradle.internal.operations")

fun isGradleExecutionCategory(s: String) =
    s.startsWith("at org.gradle.execution") ||
            s.startsWith("at org.gradle.internal.execution") ||
            s.startsWith("at org.gradle.api.internal.tasks")

fun categoryForLine(s: String): Pair<String, String?> {
    val trimmed = s.trim()
    val category = when {
        isGenericCategory(trimmed) -> null
        isBuildOperationCategory(trimmed) -> "Gradle build operation"
        isGradleExecutionCategory(trimmed) -> "Gradle execution"
        trimmed.startsWith("at org.gradle") -> "Gradle internal"
        else -> ""
    }

    return trimmed to category
}

private fun stackTraceParts(stackTraceLines: List<String>): List<ProblemNode.StackTracePart> {
    val parts = mutableListOf<ProblemNode.StackTracePart>()
    var lastCategory: String? = null
    val currentLines = mutableListOf<String>()
    for ((line, category) in stackTraceLines.map(::categoryForLine)) {
        if (category == null) {
            currentLines += line
        } else if (lastCategory == null) {
            currentLines += line
            lastCategory = category
        } else if (category == lastCategory) {
            currentLines += line
        } else {
            if (currentLines.isNotEmpty()) {
                parts += ProblemNode.StackTracePart(
                    lastCategory,
                    currentLines.toList(),
                    defaultViewStateFor(lastCategory)
                )
            }
            currentLines.clear()
            currentLines += line
            lastCategory = category
        }
    }

    if (currentLines.isNotEmpty()) {
        val actualCategory = lastCategory ?: ""
        parts += ProblemNode.StackTracePart(
            actualCategory,
            currentLines,
            defaultViewStateFor(actualCategory)
        )
    }

    return parts
}


private
fun defaultViewStateFor(lastCategory: String) = when {
    lastCategory.isEmpty() -> Tree.ViewState.Expanded
    else -> Tree.ViewState.Collapsed
}


private
fun docLinkFor(it: JsDiagnostic): ProblemNode? =
    it.documentationLink?.let { ProblemNode.Link(it, " ?") }


private
fun <T> treeModelFor(
    label: T,
    sequence: Sequence<List<T>>
): TreeView.Model<T> = TreeView.Model(
    treeFromTrie(
        label,
        Trie.from(sequence),
        Tree.ViewState.Collapsed
    )
)


private
fun <T> treeFromTrie(label: T, trie: Trie<T>, state: Tree.ViewState): Tree<T> {
    val subTreeState = if (trie.size == 1) Tree.ViewState.Expanded else Tree.ViewState.Collapsed
    return Tree(
        label,
        subTreesFromTrie(trie, subTreeState),
        // nodes with no children such as Exception nodes are considered `Collapsed` by default
        if (trie.size == 0) Tree.ViewState.Collapsed else state
    )
}


private
fun <T> subTreesFromTrie(trie: Trie<T>, state: Tree.ViewState): List<Tree<T>> =
    trie.entries.sortedBy { (label, _) -> label.toString() }.map { (label, subTrie) ->
        treeFromTrie(
            label,
            subTrie,
            state
        )
    }.toList()
